#!/bin/bash -ex

. ${EKB_BASELIB}


## hooks/content/50-endless-key-usb-image-workspace

# Fetch Windows programs, and other files, for Endless Key.
readme_url=https://images-dl.endlessm.com/endless-key/README.pdf
ek_app_version="v0.1.10"

download_github_release_file() {
  local repo=${1:?No repo supplied to ${FUNCNAME}}
  local version=${2:?No version supplied to ${FUNCNAME}}
  local filename=${3:?No filename supplied to ${FUNCNAME}}
  local output=${4:?No output supplied to ${FUNCNAME}}
  local url=$(
    curl -sSL https://api.github.com/repos/"${repo}"/releases/tags/"${version}" |
    jq -r ".assets[] | select(.name == \"${filename}\") | .browser_download_url"
  )

  ekb_download_file "$url" "$output"
}

endless_key_usb_image_workspace() {
  # Download Software packages
  ekb_download_file "$readme_url" "${EKB_CONTENT_DIR}/README.pdf"
  download_github_release_file "endlessm/endless-key-app" "${ek_app_version}" "kolibri-windows.zip" "${EKB_CONTENT_DIR}/kolibri-windows.zip"

  # Copy README
  rm -f "${EKB_TARGET_DIR}/Quick Start Guide.pdf"
  cp -rl "${EKB_CONTENT_DIR}/README.pdf" "${EKB_TARGET_DIR}/Quick Start Guide.pdf"

  # Copy Kolibri for Windows
  ekb_recreate_dir "${EKB_TARGET_DIR}/.kolibri-windows"
  unzip "${EKB_CONTENT_DIR}/kolibri-windows.zip" -d "${EKB_TARGET_DIR}/.kolibri-windows"
  # Copy Launcher dll dependency from kolibri-windows to the root
  cp "${EKB_TARGET_DIR}/.kolibri-windows/resources/app/src/Kolibri/VCRUNTIME140.dll" "${EKB_TARGET_DIR}/VCRUNTIME140.dll"

  # Copy windows 7 Universal C Runtime compatibility DLLs
  cp ${EKB_DATA_DIR}/win7-dlls/*.dll ${EKB_TARGET_DIR}/
  cp ${EKB_DATA_DIR}/win7-dlls/*.dll ${EKB_TARGET_DIR}/.kolibri-windows/resources/app/src/Kolibri/
}

endless_key_usb_image_workspace "$@"


## from helpers/create-usb-image

# Copy Windows launcher
launcher_url=$(
  curl -sSL https://api.github.com/repos/endlessm/windows-usb-launcher/releases/latest |
  jq -r '.assets[] | select(.name == "Endless.Key.Launcher.exe") | .browser_download_url'
)
ekb_download_file "${launcher_url}" "${EKB_CONTENT_DIR}/Endless Key Launcher.exe"
cp "${EKB_CONTENT_DIR}/Endless Key Launcher.exe" "${EKB_TARGET_DIR}/Endless Key Launcher.exe"


# Exit here if we are not installing Kolibri channels
if [ -z "${EKB_KOLIBRI_INSTALL_CHANNELS}" ]; then
  exit 0
fi


## hooks/image/60-endless-key-kolibri-tmp-venv

# Populate the Kolibri home directory
PYPI_KOLIBRI_VERSION=kolibri==0.15.3
PYPI_EXPLORE_PLUGIN_VERSION=kolibri-explore-plugin==2.0.14
PYPI_ZIM_PLUGIN_VERSION=kolibri-zim-plugin

kolibri_explore_plugin_tag="v2.0.14"

export KOLIBRI_HOME="${EKB_CONTENT_DIR}/kolibri-content"
ekb_recreate_dir "${KOLIBRI_HOME}"

apps_url=$(
  curl -sSL https://api.github.com/repos/endlessm/kolibri-explore-plugin/releases/tags/${kolibri_explore_plugin_tag} |
  jq -r '.assets[] | select(.name == "apps-bundle.zip") | .browser_download_url'
)

KOLIBRI_VENV_DIR="${EKB_TMP_DIR}/kolibri-content-venv"
python3 -m venv ${KOLIBRI_VENV_DIR}
source ${KOLIBRI_VENV_DIR}/bin/activate

cp "${EKB_DATA_DIR}/kolibri/options.ini" "${EKB_DATA_DIR}/kolibri/automatic_provision.json" -t "${KOLIBRI_HOME}"

pip install ${PYPI_KOLIBRI_VERSION}
pip install ${PYPI_EXPLORE_PLUGIN_VERSION}
pip install ${PYPI_ZIM_PLUGIN_VERSION}

kolibri plugin enable kolibri.plugins.app
kolibri plugin disable kolibri.plugins.learn
kolibri plugin enable kolibri_explore_plugin
kolibri plugin enable kolibri_zim_plugin

# Install the explore plugin and zim plugin in ${KOLIBRI_HOME}/extensions.
# The zim plugin is bundled with the application.
pip install ${PYPI_EXPLORE_PLUGIN_VERSION} --target="${KOLIBRI_HOME}/extensions" --platform=win_amd64 --only-binary=:all:
pip install ${PYPI_ZIM_PLUGIN_VERSION} --target="${KOLIBRI_HOME}/extensions" --platform=win_amd64 --only-binary=:all:

# Install apps bundle
ekb_download_file "${apps_url}" "${EKB_TMP_DIR}/apps-bundle.zip"
unzip -o -d "${KOLIBRI_HOME}/extensions/kolibri_explore_plugin" "${EKB_TMP_DIR}/apps-bundle.zip"


## hooks/image/61-kolibri-content-download

# Populate the Kolibri home directory

# Use a separate content URL if configured.
if [ -n "${EKB_KOLIBRI_CENTRAL_CONTENT_BASE_URL}" ]; then
  KOLIBRI_CENTRAL_CONTENT_BASE_URL="${EKB_KOLIBRI_CENTRAL_CONTENT_BASE_URL}"
  export KOLIBRI_CENTRAL_CONTENT_BASE_URL
fi

import_kolibri_channel()
{
  local channel_id=$1
  local channel_include_node_ids_var="EKB_KOLIBRI_${channel_id^^}_INCLUDE_NODE_IDS"
  local channel_exclude_node_ids_var="EKB_KOLIBRI_${channel_id^^}_EXCLUDE_NODE_IDS"
  local importcontent_opts=(
    # Normally importcontent ignores download errors. Make it fail so we
    # can be sure we've fully provisioned channels.
    --fail-on-error
  )
  local importcontent_network_opts=(
    # The default timeout is 60 seconds, but downloading can be slow
    # when objects aren't in our content CDN yet.
    --timeout 300
  )

  if [ -n "${!channel_include_node_ids_var}" ]; then
    importcontent_include_nodes=$(echo "${!channel_include_node_ids_var}" | xargs | tr -s ' ' ',')
    importcontent_opts+=(--node_ids="${importcontent_include_nodes}")
  fi

  if [ -n "${!channel_exclude_node_ids_var}" ]; then
    importcontent_exclude_nodes=$(echo "${!channel_exclude_node_ids_var}" | xargs | tr -s ' ' ',')
    importcontent_opts+=(--exclude_node_ids="${importcontent_exclude_nodes}")
  fi

  kolibri manage importchannel network "${channel_id}"
  kolibri manage importcontent "${importcontent_opts[@]}" \
    network "${importcontent_network_opts[@]}" "${channel_id}"
}

for channel_id in ${EKB_KOLIBRI_INSTALL_CHANNELS}; do
  import_kolibri_channel "${channel_id}"
done

# Sort channels in the same order as in EKB_KOLIBRI_INSTALL_CHANNELS
position=1
for channel_id in ${EKB_KOLIBRI_INSTALL_CHANNELS}; do
  kolibri manage setchannelposition ${channel_id} ${position} || true
  let position=position+1
done


## hooks/image/62-endless-key-kolibri-content-swap-placeholders

swap_placeholder() {
  local content_id=${1:?No content_id supplied to ${FUNCNAME}}
  local download_url=${2:?No download_url supplied to ${FUNCNAME}}
  local placeholder_file="${KOLIBRI_HOME}/content/storage/${content_id:0:1}/${content_id:1:1}/${content_id}"

  if [ -f "${placeholder_file}" ]; then
    ekb_download_file "${download_url}" "${EKB_TMP_DIR}/${content_id}"
    cp -f "${EKB_TMP_DIR}/${content_id}" "${placeholder_file}"
  fi
}

swap_placeholder_by_id() {
  local placeholder_id=${1//[^[:alnum:]]/_}

  local placeholder_filename_var="EKB_KOLIBRI_PLACEHOLDER_${placeholder_id^^}_STORAGE_FILENAME"
  local placeholder_download_url_var="EKB_KOLIBRI_PLACEHOLDER_${placeholder_id^^}_DOWNLOAD_URL"

  if [ -n "${!placeholder_filename_var}" ] && [ -n "${!placeholder_download_url_var}" ]; then
    swap_placeholder "${!placeholder_filename_var}" "${!placeholder_download_url_var}"
  fi
}

# Replace placeholder zim files with the real ones
if [ -n "${EKB_KOLIBRI_CONTENT_PLACEHOLDERS}" ]; then
  for placeholder_id in ${EKB_KOLIBRI_CONTENT_PLACEHOLDERS}; do
    swap_placeholder_by_id "${placeholder_id}"
  done
fi
